# ModuleSensorArchitecture
Модуль обеспечивает обобщенный стек классов для работы с сенсорами. Все создаваемые в рамках фреймворка EcoLite модули сенсоров должны быть производными от данного стека.

Стек можно условно разбить на такие части: 
- Основная, которая состоит из ветки в виде двух обобщенных классов. От этой ветки и наследуется класс конкретного датчика.
- Сервисная, реализующая математико-логический аппарат для обработки и корректировки поступаемых значений.
- Прикладная - класс, отвечающий за отдельно взятый канал датчика. Этот класс полостью зависим от последнего звена основной ветки, но также и агрегирует в себе сервисные классы.

### **ClassAncestorSensor** 
Самый "старший" предок в иерархии классов датчиков. В первую очередь собирает в себе самые базовые данные о датчике: переданные шину, пины и тд. Так же сохраняет его описательную характеристику: имя, тип вх. и вых. сигналов, типы шин которые можно использовать, количество каналов и тд.
Его инициализация происходит либо передачей в конструктор двух объектов: объекта типа **SensorOptsType** и **SensorPropsType** (описаны jsdoc комментарими), либо переджачей только первого объекта, с возможностью передать SensorPropsType непосредственно в метод initSensProps() в любой другой момент.

### **ClassMiddleSensor** 
Класс, наследующийся от **ClassAncestorSensor**. Закладывает в будущие классы датчиков поля и методы, необходимые для унификации хранения значений, полученных с каналов. Вводит реализации возможности выделения из объекта "реального" датчика объектов-каналов, которые сам же при инициализации создает и хранит в поле *_Channels*.
Если при инициализации класса-предка тот получил корректное значение *_QuantityChannel*, то в конструкторе вызываются все необходимые инструкции для автоматического создания аксессоров, в которые впредь будут передаваться значения с каналов и только с них (аксессоров) будут считываться. 
Подробнее об аксессорах. Ключевыми являются геттеры и сеттеры, создающиеся по паттерну `Ch0_Value`, `Ch1_Value` и тд., в зависимости от количества каналов. Данные аксессоры во первых, служат единой прослойкой, через которую проходят данные и соответственно лишь в сеттере можно лакончино и своевременно прогнать данные через лимиты, корректирующие функции и зоны измерения и их обработчики. "Под капотом" геттеров лежит не просто числовая переменная, в которую присваивается значение, а кольцевой буффер, который работает с массивом значений, который в дальнейшем будет передаваться в функции-фильтры 

Еще одной важнейшей целью класса является определение списика сигнатур основных методов, часть из которых так же перебрасывается в класс-канал датчика.

### **ClassChannel** 
Класс, представляющий каждый отдельно взятый канал датчика. При чем, каждый канал является "синглтоном" для своего родителя. Хранит в себе ссылки на основной объект сенсора и "проброшенные" методы для работы с данным каналом датчика. Так же именно в этом классе инстанцируются **ClassLimits** и **ClassAlarms**.
Иными словами, класс представляет собой интерфейс для работы с датчиком.

### **ClassLimits** 
Класс реализующий функционал для обработки входящих числовых значений:
1. супрессию значения по задаваемым ограничителям (лимитам)
2. корректировку соответственно заданной линейной функции kx+b

Установка ограничителей происходит вызовом метода `SetOutLim(_limLow, _limHigh)`, в котором *_limLow* и *_limHigh* - 2 упорядоченных в порядке возрастания числа

Установка коэффициентов линейной функции происходит через метод `SetTransmissonOut(_k, _b)`.

### **ClassAlarms** 
Класс реализующий функционал для работы с тревогами (алармами). Хранит в себе заданные границы алармов и соответствующие им колбэки. Границы желтой и красной зон определяются вручную, а диапазон зеленой зоны фактически подстраивается под желтую (или красную если желтая не определена).

Установка желтой и красной измерительных зон и их функций-обработчиков происходит вызовом мотода `SetYellowZone(_low, _high, _callbackLow, _callbackHigh)`, в котором *_low* и *_high* - 2 упорядоченных в порядке возрастания числа (нижняя и верхняя границы), а *_callbackLow* и *_callbackHigh* - колбэки, вызываемые при получении датчиком значения, попадающего в данную зону "сверху" и соответсвенно "снизу". Колбэки являются необязательными параметрами. А при передаче лишь одного колбэка, он будет вызываться при попадании в эту зону в обоих случаях. 
А вот для зеленой зоны устанавливается только один колэк методом `SetGreenZone(_callback)`