class ClassAncestorSensor{constructor(_opts,_sensor_props){if(!_opts.bus instanceof I2C)throw new Error("Not an I2C bus");if(_opts.pins.forEach(pin=>{if(!+Pin(pin))throw new Error("Not a pin")}),"number"!=typeof _opts.quantityChannel||_opts.quantityChannel<1)throw new Error("Invalid QuantityChannel arg ");this._Bus=_opts.bus,this._Pins=_opts.pins,this._QuantityChannel=_opts.quantityChannel,_sensor_props&&this.InitSensProperties(_sensor_props)}InitSensProperties(sensor_props){const changeNotation=str=>`_${str[0].toUpperCase()}${str.substr(1)}`;["name","type","typeInSignal","typeOutSignal"].forEach(prop=>{if("string"!=typeof sensor_props[prop])throw new Error("Incorrect sensor property");this[changeNotation(prop)]=sensor_props[prop]}),["channelNames","busType"].forEach(propArr=>{sensor_props[propArr].forEach(strElem=>{if("string"!=typeof strElem)throw new Error("Incorrect sensor property");this[changeNotation(propArr)]=sensor_props[propArr]})}),this._ManufacturingData=sensor_props.manufacturingData,this._ArePropsInited=!0}}class ClassMiddleSensor extends ClassAncestorSensor{constructor(_opts,_sensor_props){ClassAncestorSensor.apply(this,[_opts,_sensor_props]),this._Values=[],this._Channels=[],this.InitChannels(),this._IsInited=!0}get CountChannels(){return this._Channels.filter(o=>o instanceof ClassChannel).length}GetChannel(_num){const num=_num;return this._Channels[num]instanceof ClassChannel?this._Channels[num]:null}InitChannels(){if(this._IsInited)return;const defineAccessors=i=>{Object.defineProperty(this,`Ch${i}_Value`,{get:()=>this._Values[i]._arr[this._Values[i]._arr.length-1],set:val=>{this._Values[i]._rawVal=val,val=this._Channels[i]._Limits.SupressOutValue(val),val=this._Channels[i]._Limits.CalibrateOutValue(val),this._Values[i].push(val),this._Channels[i]._Alarms.CheckZones(val)}})};for(let i=0;i<this._QuantityChannel;i++){try{this._Channels[i]=new ClassChannel(this,i)}catch(e){this._Channels[i]=null}this._Values[i]={_depth:1,_rawVal:void 0,_arr:[],push:function(_val){for(;this._arr.length>=this._depth;)this._arr.shift();this._arr.push(_val)}},defineAccessors(i)}}SetFilterDepth(_ch_num,_depth){if(_ch_num<0||_ch_num>=this._QuantityChannel||_depth<1)throw new Error("Invalid args");return this._Values[_ch_num]._depth=_depth,!0}Init(_opts){}Start(_ch_num,_period,_opts){}Stop(_ch_num){}ChangeFrequency(_ch_num,_period){}ConfigureRegs(_opts){}Reset(){}SetRepeatability(_rep){}SetPrecision(_pres){}Run(_ch_num,_opts){}Read(_reg){}Write(_reg,_val){}}class ClassChannel{constructor(sensor,num){if(sensor._Channels[num]instanceof ClassChannel)return sensor._Channels[num];this._ThisSensor=sensor,this._NumChannel=num,this._Limits=new ClassLimits,this._Alarms=new ClassAlarms,sensor._Channels[num]=this}Start(_period,_opts){return this._ThisSensor.Start(this._NumChannel,_period,_opts)}Stop(){return this._ThisSensor.Stop(this._NumChannel)}ChangeFrequency(_period){return this._ThisSensor.ChangeFrequency.call(this._ThisSensor,Array.from(arguments))}Reset(){return this._ThisSensor.Reset.apply(this._ThisSensor,Array.from(arguments))}SetFilterDepth(_depth){return this._ThisSensor.SetFilterDepth(this._NumChannel,_depth)}Run(_opts){const args=Array.from(arguments);return args.unshift(this._NumChannel),this._ThisSensor.Run.apply(this._ThisSensor,args)}ConfigureRegs(_opts){return this._ThisSensor.ConfigureRegs.apply(this._ThisSensor,Array.from(arguments))}get Value(){return this._ThisSensor[`Ch${this._NumChannel}_Value`]}get ID(){return this._ThisSensor._Name+this._NumChannel}}class ClassLimits{constructor(){this._Limits=[],this.SetOutLim(-1/0,1/0),this.SetTransmissionOut(1,0)}SetOutLim(_limLow,_limHigh){if("number"!=typeof _limLow||"number"!=typeof _limHigh)throw new Error("Not a number");if(_limLow>=_limHigh)throw new Error("limLow value shoud be less than limHigh");this._Limits[0]=_limLow,this._Limits[1]=_limHigh}SupressOutValue(val){return E.clip(val,this._Limits[0],this._Limits[1])}SetTransmissionOut(_k,_b){if("number"!=typeof _k||"number"!=typeof _b)throw new Error;this._K=_k,this._B=_b}CalibrateOutValue(val){return val*this._K+this._B}}class ClassAlarms{constructor(){this._ZoneType=(low,high,cb_low,cb_high)=>({low:low,high:high,callbackLow:cb_low,callbackHigh:cb_high||cb_low,is:function(val){return val>=this.high||val<this.low},invoke:function(val){val>=this.high?this.callbackHigh(val):this.callbackLow(val)}}),this._Zones={red:this._ZoneType(),yellow:this._ZoneType(),green:{invoke:x=>x}},this._CurrentZone="green"}SetYellowZone(_low,_high,_callbackLow,_callbackHigh){if("number"!=typeof _low||"number"!=typeof _high||_low>=_high)throw new Error("Invalid args");if(_low<=this._Zones.red.low||_high>=this._Zones.red.high)throw new Error;this._Zones.yellow=this._ZoneType(_low,_high,_callbackLow,_callbackHigh)}SetRedZone(_low,_high,_callbackLow,_callbackHigh){if("number"!=typeof _low||"number"!=typeof _high||_low>=_high)throw new Error("Invalid args");if(_low>=this._Zones.yellow.low||_high<=this._Zones.yellow.high)throw new Error;this._Zones.red=this._ZoneType(_low,_high,_callbackLow,_callbackHigh)}SetGreenZone(_callback){if("function"!=typeof _callback)throw new Error("Argument is not a function");this._Zones.green={invoke:_callback}}CheckZones(val){let zone=this._Zones.red.is(val)?"red":this._Zones.yellow.is(val)?"yellow":"green";zone!==this._CurrentZone&&(this._CurrentZone=zone,this._Zones[zone].invoke(val))}}exports=ClassMiddleSensor;